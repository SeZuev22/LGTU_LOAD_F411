/*
 * encoder.c
 *
 *  Created on: Apr 29, 2025
 *      Author: Сергей
 */

#include "stm32f4xx_hal.h"
#include "tim.h"
#include "encoder.h"
#include "arm_math.h"
#include "ssd1306.h"

// Инициализация переменных
uint16_t counter_encoder = 0; // переменная для хранения значений счетчика энкодера от 0 до 300
uint8_t menu_item = 1; // переменная для хранения значений пунктов меню экрана от 1 до 2
uint8_t button_flag = 0; // переменная для хранения флага прерывания с кнопки энкодера
uint8_t short_button_flag = 0; // переменная для хранения флага кратковременного нажатия кнопки энкодера
uint8_t long_button_flag = 0; // переменная для хранения флага длительного нажатия кнопки энкодера
uint8_t short_press = 0; 	// переменная для хранения значения кнопки энкодера
uint8_t long_press = 0; 	// переменная для хранения значения кнопки энкодера
uint32_t time_key = 0; 			// время нажатия кнопки

// Переменные для редактирования энкодером
float32_t current_value = 10.0f; // переменная для хранения значения тока настроенного энкодером
float32_t voltage_value = 15.0f; // переменная для хранения значения напряжения настроенного энкодером

// Функция обработки функции HAL на включение всех каналов первого таймера энкодера
void Encoder_Init(void) {
	HAL_TIM_Encoder_Start_IT(&htim1, TIM_CHANNEL_ALL); // Запускаем энкодер в режиме прерывания и запускаем все проинициализированные каналы таймера 1
}


// Функция обработки кратковременных и длительных нажатий кнопки энкодера
void Button_click_process() {
	uint32_t ms = HAL_GetTick(); // получаем текущее время тиков
	uint8_t key1_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_14); // считываем текущее состояние кнопки
	// Если кнопка нажата и до этого не было кратковременного нажатия и прошло более 50мс
	if (key1_state == 0 && !short_button_flag && (ms - time_key) > 200) {
		short_button_flag = 1; // Устанавливаем флаг кратковременного нажатия
		long_button_flag = 0; // Сбрасываем флаг длительного нажатия
		time_key = ms; // Обновляем время
		// в противном случае если кнопка нажата и до этого не было длительного нажатия и прошло более 2 секунд
	} else if (key1_state == 0 && !long_button_flag && (ms - time_key) > 2000) {
		long_button_flag = 1; // Устанавливаем флаг длительного нажатия
		Long_Press(); // Вызываем функцию дальнейшей обработки длительного нажатия
		// в противном случае если кнопка отпущена, при этом было кратковременное нажатие и прошло более 50мс
	} else if (key1_state == 1 && short_button_flag && (ms - time_key) > 200) {
		short_button_flag = 0; // сбрасывем флаг кратковременного нажатия
		time_key = ms; // обновляем время
		if (!long_button_flag) { // если при этом не было зафиксировано длительное нажатие
			Short_Press(); // вызываем функцию дальнейшей обработки кратковременного нажатия
		}
	}
}

// Функция обработки кратковременного нажатия
void Short_Press() {
	short_press = !short_press; // Инвертируем переменную в зависимости от нажатий кнопки
	button_flag = 0; // Сбрасываем флаг прерывания
}

// Функция обработки длительного нажатия
void Long_Press() {
	if (short_press == 0) {
		long_press = !long_press; // Инвертируем переменную в зависимости от нажатий кнопки при условии что короткое нажатие не установлено
		short_button_flag = 0;
		button_flag = 0; // Сбрасываем флаг прерывания
	}
}

