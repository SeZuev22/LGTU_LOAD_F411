/*
 * encoder.c
 *
 *  Created on: Apr 29, 2025
 *      Author: Сергей
 */

#include "stm32f4xx_hal.h"
#include "tim.h"
#include "encoder.h"
#include "arm_math.h"
#include "ssd1306.h"

// Инициализация переменных
uint16_t counter_encoder = 0; 	// переменная для хранения значений счетчика энкодера от 0 до 300
uint8_t menu_item = 1; 			// переменная для хранения значений пунктов меню экрана от 1 до 2
uint8_t button_flag = 0; 		// переменная для хранения флага прерывания с кнопки энкодера
uint8_t short_button_flag = 0; 	// переменная для хранения флага кратковременного нажатия кнопки энкодера
uint8_t long_button_flag = 0; 	// переменная для хранения флага длительного нажатия кнопки энкодера
uint8_t short_press = 0; 		// переменная для хранения значения кнопки энкодера
uint8_t long_press = 0; 		// переменная для хранения значения кнопки энкодера
uint32_t time_key = 0; 			// время нажатия кнопки

// Переменные для редактирования энкодером
float32_t current_value = 10.0f; // переменная для хранения значения тока настроенного энкодером
float32_t voltage_value = 15.0f; // переменная для хранения значения напряжения настроенного энкодером

// Функция обработки функции HAL на включение всех каналов первого таймера энкодера
void Encoder_Init(void) {
	HAL_TIM_Encoder_Start_IT(&htim1, TIM_CHANNEL_ALL); // Запускаем энкодер в режиме прерывания и запускаем все проинициализированные каналы таймера 1
}

// Функция обработки прерывания от таймера энкодера
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim) {
   if(htim->Instance == TIM1) { // Проверяем, что прерывание пришло от таймера 1
	   counter_encoder = TIM1->CNT; // считываем значение регистра счетчика таймера 1
   if (short_press == 0) {
	   menu_item = (counter_encoder / 2) % 2 + 1; // Если короткое нажатие не активно, преобразуем 0-300 в 1-2;
      }
   if (short_press == 1) {
	   if (menu_item == 2) {
		   current_value = (float32_t)(counter_encoder) / 20.0f; // Вычисляем значение тока с шагом 0.1
		   if (current_value > 10.0f) current_value = 10.0f; // Ограничение максимального значения
		   upd_chisl(current_value, 1); // обновляем значение тока на экране
	   } else if (menu_item == 1) {
		   voltage_value = (float32_t)(counter_encoder) / 20.0f; // Вычисляем значение напряжения с шагом 0.1
		   //if (voltage_value > 15.0f) voltage_value = 15.0f; // Можно не ограничивать так как максимальное значение = 15
		   upd_chisl(voltage_value, 2); // обновляем значение напряжения на экране
	   }
   }
   }
}

// Функция обработки прерывания от кнопки энкодера
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
	if (GPIO_Pin == GPIO_PIN_14) { // Проверяем что прерывание от GPIO_PIN_14
		button_flag = 1; // Устанавливаем флажок, что пришло прерывание от кнопки энкодера
	}
}

// Функция обработки кратковременных и длительных нажатий кнопки энкодера
void Button_click_process() {
	uint32_t ms = HAL_GetTick(); // получаем текущее время тиков
	uint8_t key1_state = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_14); // считываем текущее состояние кнопки
	// Если кнопка нажата и до этого не было кратковременного нажатия и прошло более 50мс
	if (key1_state == 0 && !short_button_flag && (ms - time_key) > 200) {
		short_button_flag = 1; // Устанавливаем флаг кратковременного нажатия
		long_button_flag = 0; // Сбрасываем флаг длительного нажатия
		time_key = ms; // Обновляем время
	// в противном случае если кнопка нажата и до этого не было длительного нажатия и прошло более 2 секунд
	} else if (key1_state == 0 && !long_button_flag && (ms - time_key) > 2000) {
		long_button_flag = 1; // Устанавливаем флаг длительного нажатия
		Long_Press(); // Вызываем функцию дальнейшей обработки длительного нажатия
	// в противном случае если кнопка отпущена, при этом было кратковременное нажатие и прошло более 50мс
	} else if (key1_state == 1 && short_button_flag && (ms - time_key) > 200) {
		short_button_flag = 0; // сбрасывем флаг кратковременного нажатия
		time_key = ms; // обновляем время
		if (!long_button_flag) { // если при этом не было зафиксировано длительное нажатие
			Short_Press(); // вызываем функцию дальнейшей обработки кратковременного нажатия
		}
	}
}

// Функция обработки кратковременного нажатия
void Short_Press() {
	short_press = !short_press; // Переключаем переменную в зависимости от нажатий кнопки
	button_flag = 0; // Сбрасываем флаг прерывания
}

// Функция обработки длительного нажатия
void Long_Press() {
	if (short_press == 0) {
    long_press = !long_press; // Переключаем переменную в зависимости от нажатий кнопки при условии что короткое нажатие не установлено
    short_button_flag = 0;
    button_flag = 0; // Сбрасываем флаг прерывания
	}
}

